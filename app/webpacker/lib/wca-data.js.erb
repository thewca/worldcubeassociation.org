import _ from 'lodash';
import I18n from './i18n';

const dataFileContext = require.context('rails_data');
const loadRawData = (modelName) => dataFileContext(`./${modelName}.json`);

const camelizeKeys = (obj) => _.mapKeys(obj, (v, k) => _.camelCase(k))

const dataLookup = (modelName) => {
  const rawEntities = loadRawData(modelName);
  return _.map(rawEntities, camelizeKeys);
};

/* We bundle all backend data constants in one big file, because the way we currently
 * export the Ruby values to JS is very inefficient (it basically spins up an entire server per file)
 *
 * As a result, this file is very cluttered for the time being. But we need this as an intermediate solution
 * in order not to fry our own servers when compiling assets. A more permanent solution would be advisable.
 *
 * Signed GB 12-16-2022
 * See https://github.com/thewca/worldcubeassociation.org/issues/7284 for details.
 */

// ----- COUNTRIES -----

const realCountryData = loadRawData('<%= Country.data_file_handle %>.real')['states_list']['states'];
const fictionalCountryData = dataLookup('<%= Country.data_file_handle %>.fictional');

const countryData = [...realCountryData, ...fictionalCountryData];

export const countries = {
  byIso2: _.mapValues(_.keyBy(countryData, 'iso2'), extendCountries),
  real: _.map(realCountryData, extendCountries),
};

function extendCountries(country) {
  return {
    ...country,
    name: I18n.t(`countries.${country.iso2}`),
  };
}

// ----- CONTINENTS -----

const continentData = dataLookup('<%= Continent.data_file_handle %>');

const fictionalContinentIds = <%= Continent.fictive_ids.to_json.html_safe %>;
const realContinents = continentData.filter((c) => !fictionalContinentIds.includes(c.id));

export const continents = {
  real: _.map(realContinents, extendContinents),
};

function extendContinents(continent){
  return {
    ...continent,
    name: I18n.t(`continents.${continent.name}`),
  };
}

// ----- CURRENCIES -----

<%
  # Select currencies, for all the iso_code is matching the hash key.
  # However for 2 currencies (JPY, GHS) there is a second currency with the same iso_code but a different key.
  # They exist for backward compatibilities reason (see here: https://github.com/RubyMoney/money/blob/190683e7b84b66d11b83b7be32d019cf3c2fc114/config/currency_backwards_compatible.json), and we actually don't use them.
  selected_currencies = Money::Currency.table.select { |k,v| k.to_s == v[:iso_code].downcase }
  currencies_info_hash = Hash[selected_currencies.map do |_,v|
    [v[:iso_code], {:symbol => v[:symbol],
                    :symbol_first => v[:symbol_first],
                    :subunit_to_unit => v[:subunit_to_unit],
                    :name => v[:name]}]
  end]
%>

export const currenciesData = {
  byIso: _.mapValues(<%= currencies_info_hash.to_json.html_safe %>, extendCurrenciesData),
};

function extendCurrenciesData(rawFormat) {
  return _.mapKeys(rawFormat, (v, k) => _.camelCase(k));
}

// ----- FORMATS -----

const formatsData = dataLookup('<%= Format.data_file_handle %>');

const allowedFirstPhaseFormats = <%= Format::ALLOWED_FIRST_PHASE_FORMATS.to_json.html_safe %>;

export const formats = {
  byId: _.mapValues(_.keyBy(formatsData, 'id'), extendFormats),
};

function extendFormats(rawFormat) {
  return {
    ...rawFormat,
    name: I18n.t(`formats.${rawFormat.id}`),
    shortName: I18n.t(`formats.short.${rawFormat.id}`),
    allowedFirstPhaseFormats: allowedFirstPhaseFormats[rawFormat.id],
  };
}

// ----- PREFERRED FORMATS -----

const preferredFormatsData = dataLookup('<%= PreferredFormat.data_file_handle %>');

export const preferredFormats = {
  byEventId: _.mapValues(_.keyBy(preferredFormatsData, 'eventId'), extendPreferredFormats),
  byFormatId: _.mapValues(_.keyBy(preferredFormatsData, 'formatId'), extendPreferredFormats),
};

function extendPreferredFormats(rawPreferredFormat) {
  // Simple identity right now but we may want to add cool stuff in the future
  return rawPreferredFormat;
}

// ----- EVENTS -----

const eventsData = dataLookup('<%= Event.data_file_handle %>');

const eventsWithoutCutoff = <%= Event::EVENTS_WITHOUT_CUTOFF.to_json.html_safe %>;
const multipleBlindfoldedEvents = <%= Event::MULTIPLE_BLINDFOLDED_EVENTS.to_json.html_safe %>;
const fewestMovesEvents = <%= Event::FEWEST_MOVES_EVENTS.to_json.html_safe %>;

export const events = {
  official: _.map(_.filter(eventsData, 'official'), extendEvents),
  byId: _.mapValues(_.keyBy(eventsData, 'id'), extendEvents),
};

function extendEvents(rawEvent) {
  const canHaveCutoff = eventsWithoutCutoff.includes(rawEvent.id);
  const isMultipleBlindfolded = multipleBlindfoldedEvents.includes(rawEvent.id);
  const isFewestMoves = fewestMovesEvents.includes(rawEvent.id);

  return {
    ...rawEvent,
    name: I18n.t(`events.${rawEvent.id}`),
    canHaveCutoff,
    isFewestMoves,
    isMultipleBlindfolded,
    canChangeTimeLimit: !isFewestMoves && !isMultipleBlindfolded,
    isTimedEvent: !isFewestMoves && !isMultipleBlindfolded,
    formats() {
      return preferredFormats.byEventId[rawEvent.id].map((prefFormat) => formats.byId[prefFormat.formatId]);
    },
    recommendedFormat() {
      return this.formats()[0];
    },
  }
}

// ----- GENDERS -----

export const genders = {
  byId: _.mapValues(<%= User::ALLOWABLE_GENDERS.index_by(&:itself).to_json.html_safe %>, extendGenders),
};

function extendGenders(gender) {
  return {
    id: gender,
    name: I18n.t(`enums.user.gender.${gender}`),
  };
}

// ----- ROUND TYPES -----

const roundTypeData = dataLookup('<%= RoundType.data_file_handle %>');

export const roundTypes = {
  byId: _.mapValues(_.keyBy(roundTypeData, 'id'), extendRoundTypes),
};

function extendRoundTypes(rawFormat) {
  // Simple identity right now but we may want to add cool stuff in the future
  return rawFormat;
}

// ----- TIMEZONES -----

export const timezoneData = <%= Country::ALL_TIMEZONES_MAPPING.to_json.html_safe %>;

export function friendlyTimezoneName(id) {
  return _.findKey(timezoneData, { id }) || id;
}

// ----- REGIONAL MARKERS -----

export const regionalMarkers = <%= Result::MARKERS.to_json.html_safe %>;

// ----- VENUE ROOM COLORS -----

export const defaultRoomColor = "<%= VenueRoom::DEFAULT_ROOM_COLOR %>";

// ----- COMPETITION DATA -----

export const competitionConstants = {
  competitionRecentDays: <%= Competition::RECENT_DAYS %>,
};

const currentYear = (new Date()).getFullYear();
const yearsRange = _.range(2003, currentYear, 1); // range end is exclusive

// Calling Ruby's `Competition.non_future_years` triggers a DB call, which we don't want.
// So we "fake" values by accepting that there was one competition in 1982 and then comps started in 2003 again.
export const nonFutureCompetitionYears = [1982, ...yearsRange];

// ----- RAILS ENV -----

export const railsEnv = '<%= Rails.env %>';

export const RECAPTCHA_PUBLIC_KEY = '<%= AppSecrets.RECAPTCHA_PUBLIC_KEY %>';

// ----- COMP RULES -----

export const nearbyCompetitionDistanceWarning = <%= Competition::NEARBY_DISTANCE_KM_WARNING.to_json.html_safe %>

export const nearbyCompetitionDistanceDanger = <%= Competition::NEARBY_DISTANCE_KM_DANGER.to_json.html_safe %>

export const competitionMaxShortNameLength = <%= Competition::MAX_CELL_NAME_LENGTH.to_json.html_safe %>

// ----- CHAMPIONSHIPS -----

const eligibleCountryForChampionshipData = dataLookup('<%= EligibleCountryIso2ForChampionship.data_file_handle %>');

export const championshipTypeWorld = '<%= Championship::CHAMPIONSHIP_TYPE_WORLD %>'

export const groupedChampionshipTypes = {
  planetary: [championshipTypeWorld],
  continental: _.map(_.sortBy(continents.real, 'name'), 'id'),
  "multi-national": _.uniq(_.map(eligibleCountryForChampionshipData, 'championshipType')),
  national: _.map(_.sortBy(countries.real, 'name'), 'iso2'),
}

// ----- ROLES & GROUPS -----

export const groupTypes = JSON.parse('<%= UserGroup.group_types.to_json.html_safe %>');

// This hard-coding is temporary. Once we have `roles_metadata_councils` table, we will have a model
// `roles_metadata_councils` and we will be able to fetch this data from there.

export const teamsCommitteesStatus = {
  member: 'member',
  senior_member: 'senior_member',
  leader: 'leader',
};

export const councilsStatus = {
  member: 'member',
  senior_member: 'senior_member',
  leader: 'leader',
};

export const delegateRegionsStatus = <%= RolesMetadataDelegateRegions.statuses.to_json %>;

export const officersStatus = <%= RolesMetadataOfficers.statuses.to_json %>;

export const banScopes = <%= RolesMetadataBannedCompetitors.scopes.to_json %>

// ----- PANEL PAGES -----
export const PANEL_PAGES = <%= PanelController.panel_pages.to_json.html_safe %>;
