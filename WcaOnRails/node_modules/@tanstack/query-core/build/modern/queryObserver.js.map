{"version":3,"sources":["../../src/queryObserver.ts"],"sourcesContent":["import {\n  isServer,\n  isValidTimeout,\n  noop,\n  replaceData,\n  shallowEqualObjects,\n  timeUntilStale,\n} from './utils'\nimport { notifyManager } from './notifyManager'\nimport { focusManager } from './focusManager'\nimport { Subscribable } from './subscribable'\nimport { canFetch } from './retryer'\nimport type { QueryClient } from './queryClient'\nimport type { FetchOptions, Query, QueryState } from './query'\nimport type {\n  DefaultError,\n  DefaultedQueryObserverOptions,\n  PlaceholderDataFunction,\n  QueryKey,\n  QueryObserverBaseResult,\n  QueryObserverOptions,\n  QueryObserverResult,\n  QueryOptions,\n  RefetchOptions,\n} from './types'\n\ntype QueryObserverListener<TData, TError> = (\n  result: QueryObserverResult<TData, TError>,\n) => void\n\nexport interface NotifyOptions {\n  listeners?: boolean\n}\n\nexport interface ObserverFetchOptions extends FetchOptions {\n  throwOnError?: boolean\n}\n\nexport class QueryObserver<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Subscribable<QueryObserverListener<TData, TError>> {\n  #client: QueryClient\n  #currentQuery: Query<TQueryFnData, TError, TQueryData, TQueryKey> = undefined!\n  #currentQueryInitialState: QueryState<TQueryData, TError> = undefined!\n  #currentResult: QueryObserverResult<TData, TError> = undefined!\n  #currentResultState?: QueryState<TQueryData, TError>\n  #currentResultOptions?: QueryObserverOptions<\n    TQueryFnData,\n    TError,\n    TData,\n    TQueryData,\n    TQueryKey\n  >\n  #selectError: TError | null\n  #selectFn?: (data: TQueryData) => TData\n  #selectResult?: TData\n  // This property keeps track of the last query with defined data.\n  // It will be used to pass the previous data and query to the placeholder function between renders.\n  #lastQueryWithDefinedData?: Query<TQueryFnData, TError, TQueryData, TQueryKey>\n  #staleTimeoutId?: ReturnType<typeof setTimeout>\n  #refetchIntervalId?: ReturnType<typeof setInterval>\n  #currentRefetchInterval?: number | false\n  #trackedProps: Set<keyof QueryObserverResult> = new Set()\n\n  constructor(\n    client: QueryClient,\n    public options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ) {\n    super()\n\n    this.#client = client\n    this.#selectError = null\n    this.bindMethods()\n    this.setOptions(options)\n  }\n\n  protected bindMethods(): void {\n    this.refetch = this.refetch.bind(this)\n  }\n\n  protected onSubscribe(): void {\n    if (this.listeners.size === 1) {\n      this.#currentQuery.addObserver(this)\n\n      if (shouldFetchOnMount(this.#currentQuery, this.options)) {\n        this.#executeFetch()\n      } else {\n        this.updateResult()\n      }\n\n      this.#updateTimers()\n    }\n  }\n\n  protected onUnsubscribe(): void {\n    if (!this.hasListeners()) {\n      this.destroy()\n    }\n  }\n\n  shouldFetchOnReconnect(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnReconnect,\n    )\n  }\n\n  shouldFetchOnWindowFocus(): boolean {\n    return shouldFetchOn(\n      this.#currentQuery,\n      this.options,\n      this.options.refetchOnWindowFocus,\n    )\n  }\n\n  destroy(): void {\n    this.listeners = new Set()\n    this.#clearStaleTimeout()\n    this.#clearRefetchInterval()\n    this.#currentQuery.removeObserver(this)\n  }\n\n  setOptions(\n    options?: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n    notifyOptions?: NotifyOptions,\n  ): void {\n    const prevOptions = this.options\n    const prevQuery = this.#currentQuery\n\n    this.options = this.#client.defaultQueryOptions(options)\n\n    if (!shallowEqualObjects(prevOptions, this.options)) {\n      this.#client.getQueryCache().notify({\n        type: 'observerOptionsUpdated',\n        query: this.#currentQuery,\n        observer: this,\n      })\n    }\n\n    if (\n      typeof this.options.enabled !== 'undefined' &&\n      typeof this.options.enabled !== 'boolean'\n    ) {\n      throw new Error('Expected enabled to be a boolean')\n    }\n\n    // Keep previous query key if the user does not supply one\n    if (!this.options.queryKey) {\n      this.options.queryKey = prevOptions.queryKey\n    }\n\n    this.#updateQuery()\n\n    const mounted = this.hasListeners()\n\n    // Fetch if there are subscribers\n    if (\n      mounted &&\n      shouldFetchOptionally(\n        this.#currentQuery,\n        prevQuery,\n        this.options,\n        prevOptions,\n      )\n    ) {\n      this.#executeFetch()\n    }\n\n    // Update result\n    this.updateResult(notifyOptions)\n\n    // Update stale interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        this.options.staleTime !== prevOptions.staleTime)\n    ) {\n      this.#updateStaleTimeout()\n    }\n\n    const nextRefetchInterval = this.#computeRefetchInterval()\n\n    // Update refetch interval if needed\n    if (\n      mounted &&\n      (this.#currentQuery !== prevQuery ||\n        this.options.enabled !== prevOptions.enabled ||\n        nextRefetchInterval !== this.#currentRefetchInterval)\n    ) {\n      this.#updateRefetchInterval(nextRefetchInterval)\n    }\n  }\n\n  getOptimisticResult(\n    options: DefaultedQueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const query = this.#client.getQueryCache().build(this.#client, options)\n\n    const result = this.createResult(query, options)\n\n    if (shouldAssignObserverCurrentProperties(this, result)) {\n      // this assigns the optimistic result to the current Observer\n      // because if the query function changes, useQuery will be performing\n      // an effect where it would fetch again.\n      // When the fetch finishes, we perform a deep data cloning in order\n      // to reuse objects references. This deep data clone is performed against\n      // the `observer.currentResult.data` property\n      // When QueryKey changes, we refresh the query and get new `optimistic`\n      // result, while we leave the `observer.currentResult`, so when new data\n      // arrives, it finds the old `observer.currentResult` which is related\n      // to the old QueryKey. Which means that currentResult and selectData are\n      // out of sync already.\n      // To solve this, we move the cursor of the currentResult every time\n      // an observer reads an optimistic value.\n\n      // When keeping the previous data, the result doesn't change until new\n      // data arrives.\n      this.#currentResult = result\n      this.#currentResultOptions = this.options\n      this.#currentResultState = this.#currentQuery.state\n    }\n    return result\n  }\n\n  getCurrentResult(): QueryObserverResult<TData, TError> {\n    return this.#currentResult\n  }\n\n  trackResult(\n    result: QueryObserverResult<TData, TError>,\n  ): QueryObserverResult<TData, TError> {\n    const trackedResult = {} as QueryObserverResult<TData, TError>\n\n    Object.keys(result).forEach((key) => {\n      Object.defineProperty(trackedResult, key, {\n        configurable: false,\n        enumerable: true,\n        get: () => {\n          this.#trackedProps.add(key as keyof QueryObserverResult)\n          return result[key as keyof QueryObserverResult]\n        },\n      })\n    })\n\n    return trackedResult\n  }\n\n  getCurrentQuery(): Query<TQueryFnData, TError, TQueryData, TQueryKey> {\n    return this.#currentQuery\n  }\n\n  refetch({ ...options }: RefetchOptions = {}): Promise<\n    QueryObserverResult<TData, TError>\n  > {\n    return this.fetch({\n      ...options,\n    })\n  }\n\n  fetchOptimistic(\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    const defaultedOptions = this.#client.defaultQueryOptions(options)\n\n    const query = this.#client\n      .getQueryCache()\n      .build(this.#client, defaultedOptions)\n    query.isFetchingOptimistic = true\n\n    return query.fetch().then(() => this.createResult(query, defaultedOptions))\n  }\n\n  protected fetch(\n    fetchOptions: ObserverFetchOptions,\n  ): Promise<QueryObserverResult<TData, TError>> {\n    return this.#executeFetch({\n      ...fetchOptions,\n      cancelRefetch: fetchOptions.cancelRefetch ?? true,\n    }).then(() => {\n      this.updateResult()\n      return this.#currentResult\n    })\n  }\n\n  #executeFetch(\n    fetchOptions?: ObserverFetchOptions,\n  ): Promise<TQueryData | undefined> {\n    // Make sure we reference the latest query as the current one might have been removed\n    this.#updateQuery()\n\n    // Fetch\n    let promise: Promise<TQueryData | undefined> = this.#currentQuery.fetch(\n      this.options as QueryOptions<TQueryFnData, TError, TQueryData, TQueryKey>,\n      fetchOptions,\n    )\n\n    if (!fetchOptions?.throwOnError) {\n      promise = promise.catch(noop)\n    }\n\n    return promise\n  }\n\n  #updateStaleTimeout(): void {\n    this.#clearStaleTimeout()\n\n    if (\n      isServer ||\n      this.#currentResult.isStale ||\n      !isValidTimeout(this.options.staleTime)\n    ) {\n      return\n    }\n\n    const time = timeUntilStale(\n      this.#currentResult.dataUpdatedAt,\n      this.options.staleTime,\n    )\n\n    // The timeout is sometimes triggered 1 ms before the stale time expiration.\n    // To mitigate this issue we always add 1 ms to the timeout.\n    const timeout = time + 1\n\n    this.#staleTimeoutId = setTimeout(() => {\n      if (!this.#currentResult.isStale) {\n        this.updateResult()\n      }\n    }, timeout)\n  }\n\n  #computeRefetchInterval() {\n    return (\n      (typeof this.options.refetchInterval === 'function'\n        ? this.options.refetchInterval(this.#currentQuery)\n        : this.options.refetchInterval) ?? false\n    )\n  }\n\n  #updateRefetchInterval(nextInterval: number | false): void {\n    this.#clearRefetchInterval()\n\n    this.#currentRefetchInterval = nextInterval\n\n    if (\n      isServer ||\n      this.options.enabled === false ||\n      !isValidTimeout(this.#currentRefetchInterval) ||\n      this.#currentRefetchInterval === 0\n    ) {\n      return\n    }\n\n    this.#refetchIntervalId = setInterval(() => {\n      if (\n        this.options.refetchIntervalInBackground ||\n        focusManager.isFocused()\n      ) {\n        this.#executeFetch()\n      }\n    }, this.#currentRefetchInterval)\n  }\n\n  #updateTimers(): void {\n    this.#updateStaleTimeout()\n    this.#updateRefetchInterval(this.#computeRefetchInterval())\n  }\n\n  #clearStaleTimeout(): void {\n    if (this.#staleTimeoutId) {\n      clearTimeout(this.#staleTimeoutId)\n      this.#staleTimeoutId = undefined\n    }\n  }\n\n  #clearRefetchInterval(): void {\n    if (this.#refetchIntervalId) {\n      clearInterval(this.#refetchIntervalId)\n      this.#refetchIntervalId = undefined\n    }\n  }\n\n  protected createResult(\n    query: Query<TQueryFnData, TError, TQueryData, TQueryKey>,\n    options: QueryObserverOptions<\n      TQueryFnData,\n      TError,\n      TData,\n      TQueryData,\n      TQueryKey\n    >,\n  ): QueryObserverResult<TData, TError> {\n    const prevQuery = this.#currentQuery\n    const prevOptions = this.options\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n    const prevResultState = this.#currentResultState\n    const prevResultOptions = this.#currentResultOptions\n    const queryChange = query !== prevQuery\n    const queryInitialState = queryChange\n      ? query.state\n      : this.#currentQueryInitialState\n\n    const { state } = query\n    let { error, errorUpdatedAt, fetchStatus, status } = state\n    let isPlaceholderData = false\n    let data: TData | undefined\n\n    // Optimistically set result in fetching state if needed\n    if (options._optimisticResults) {\n      const mounted = this.hasListeners()\n\n      const fetchOnMount = !mounted && shouldFetchOnMount(query, options)\n\n      const fetchOptionally =\n        mounted && shouldFetchOptionally(query, prevQuery, options, prevOptions)\n\n      if (fetchOnMount || fetchOptionally) {\n        fetchStatus = canFetch(query.options.networkMode)\n          ? 'fetching'\n          : 'paused'\n        if (!state.dataUpdatedAt) {\n          status = 'pending'\n        }\n      }\n      if (options._optimisticResults === 'isRestoring') {\n        fetchStatus = 'idle'\n      }\n    }\n\n    // Select data if needed\n    if (options.select && typeof state.data !== 'undefined') {\n      // Memoize select result\n      if (\n        prevResult &&\n        state.data === prevResultState?.data &&\n        options.select === this.#selectFn\n      ) {\n        data = this.#selectResult\n      } else {\n        try {\n          this.#selectFn = options.select\n          data = options.select(state.data)\n          data = replaceData(prevResult?.data, data, options)\n          this.#selectResult = data\n          this.#selectError = null\n        } catch (selectError) {\n          this.#selectError = selectError as TError\n        }\n      }\n    }\n    // Use query data\n    else {\n      data = state.data as unknown as TData\n    }\n\n    // Show placeholder data if needed\n    if (\n      typeof options.placeholderData !== 'undefined' &&\n      typeof data === 'undefined' &&\n      status === 'pending'\n    ) {\n      let placeholderData\n\n      // Memoize placeholder data\n      if (\n        prevResult?.isPlaceholderData &&\n        options.placeholderData === prevResultOptions?.placeholderData\n      ) {\n        placeholderData = prevResult.data\n      } else {\n        placeholderData =\n          typeof options.placeholderData === 'function'\n            ? (\n                options.placeholderData as unknown as PlaceholderDataFunction<TQueryData>\n              )(\n                this.#lastQueryWithDefinedData?.state.data,\n                this.#lastQueryWithDefinedData as any,\n              )\n            : options.placeholderData\n        if (options.select && typeof placeholderData !== 'undefined') {\n          try {\n            placeholderData = options.select(placeholderData)\n            this.#selectError = null\n          } catch (selectError) {\n            this.#selectError = selectError as TError\n          }\n        }\n      }\n\n      if (typeof placeholderData !== 'undefined') {\n        status = 'success'\n        data = replaceData(\n          prevResult?.data,\n          placeholderData as unknown,\n          options,\n        ) as TData\n        isPlaceholderData = true\n      }\n    }\n\n    if (this.#selectError) {\n      error = this.#selectError as any\n      data = this.#selectResult\n      errorUpdatedAt = Date.now()\n      status = 'error'\n    }\n\n    const isFetching = fetchStatus === 'fetching'\n    const isPending = status === 'pending'\n    const isError = status === 'error'\n\n    const isLoading = isPending && isFetching\n\n    const result: QueryObserverBaseResult<TData, TError> = {\n      status,\n      fetchStatus,\n      isPending,\n      isSuccess: status === 'success',\n      isError,\n      isInitialLoading: isLoading,\n      isLoading,\n      data,\n      dataUpdatedAt: state.dataUpdatedAt,\n      error,\n      errorUpdatedAt,\n      failureCount: state.fetchFailureCount,\n      failureReason: state.fetchFailureReason,\n      errorUpdateCount: state.errorUpdateCount,\n      isFetched: state.dataUpdateCount > 0 || state.errorUpdateCount > 0,\n      isFetchedAfterMount:\n        state.dataUpdateCount > queryInitialState.dataUpdateCount ||\n        state.errorUpdateCount > queryInitialState.errorUpdateCount,\n      isFetching,\n      isRefetching: isFetching && !isPending,\n      isLoadingError: isError && state.dataUpdatedAt === 0,\n      isPaused: fetchStatus === 'paused',\n      isPlaceholderData,\n      isRefetchError: isError && state.dataUpdatedAt !== 0,\n      isStale: isStale(query, options),\n      refetch: this.refetch,\n    }\n\n    return result as QueryObserverResult<TData, TError>\n  }\n\n  updateResult(notifyOptions?: NotifyOptions): void {\n    const prevResult = this.#currentResult as\n      | QueryObserverResult<TData, TError>\n      | undefined\n\n    const nextResult = this.createResult(this.#currentQuery, this.options)\n    this.#currentResultState = this.#currentQuery.state\n    this.#currentResultOptions = this.options\n\n    if (this.#currentResultState.data !== undefined) {\n      this.#lastQueryWithDefinedData = this.#currentQuery\n    }\n\n    // Only notify and update result if something has changed\n    if (shallowEqualObjects(nextResult, prevResult)) {\n      return\n    }\n\n    this.#currentResult = nextResult\n\n    // Determine which callbacks to trigger\n    const defaultNotifyOptions: NotifyOptions = {}\n\n    const shouldNotifyListeners = (): boolean => {\n      if (!prevResult) {\n        return true\n      }\n\n      const { notifyOnChangeProps } = this.options\n      const notifyOnChangePropsValue =\n        typeof notifyOnChangeProps === 'function'\n          ? notifyOnChangeProps()\n          : notifyOnChangeProps\n\n      if (\n        notifyOnChangePropsValue === 'all' ||\n        (!notifyOnChangePropsValue && !this.#trackedProps.size)\n      ) {\n        return true\n      }\n\n      const includedProps = new Set(\n        notifyOnChangePropsValue ?? this.#trackedProps,\n      )\n\n      if (this.options.throwOnError) {\n        includedProps.add('error')\n      }\n\n      return Object.keys(this.#currentResult).some((key) => {\n        const typedKey = key as keyof QueryObserverResult\n        const changed = this.#currentResult[typedKey] !== prevResult[typedKey]\n        return changed && includedProps.has(typedKey)\n      })\n    }\n\n    if (notifyOptions?.listeners !== false && shouldNotifyListeners()) {\n      defaultNotifyOptions.listeners = true\n    }\n\n    this.#notify({ ...defaultNotifyOptions, ...notifyOptions })\n  }\n\n  #updateQuery(): void {\n    const query = this.#client.getQueryCache().build(this.#client, this.options)\n\n    if (query === this.#currentQuery) {\n      return\n    }\n\n    const prevQuery = this.#currentQuery as\n      | Query<TQueryFnData, TError, TQueryData, TQueryKey>\n      | undefined\n    this.#currentQuery = query\n    this.#currentQueryInitialState = query.state\n\n    if (this.hasListeners()) {\n      prevQuery?.removeObserver(this)\n      query.addObserver(this)\n    }\n  }\n\n  onQueryUpdate(): void {\n    this.updateResult()\n\n    if (this.hasListeners()) {\n      this.#updateTimers()\n    }\n  }\n\n  #notify(notifyOptions: NotifyOptions): void {\n    notifyManager.batch(() => {\n      // First, trigger the listeners\n      if (notifyOptions.listeners) {\n        this.listeners.forEach((listener) => {\n          listener(this.#currentResult)\n        })\n      }\n\n      // Then the cache listeners\n      this.#client.getQueryCache().notify({\n        query: this.#currentQuery,\n        type: 'observerResultsUpdated',\n      })\n    })\n  }\n}\n\nfunction shouldLoadOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    !query.state.dataUpdatedAt &&\n    !(query.state.status === 'error' && options.retryOnMount === false)\n  )\n}\n\nfunction shouldFetchOnMount(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    shouldLoadOnMount(query, options) ||\n    (query.state.dataUpdatedAt > 0 &&\n      shouldFetchOn(query, options, options.refetchOnMount))\n  )\n}\n\nfunction shouldFetchOn(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  field: (typeof options)['refetchOnMount'] &\n    (typeof options)['refetchOnWindowFocus'] &\n    (typeof options)['refetchOnReconnect'],\n) {\n  if (options.enabled !== false) {\n    const value = typeof field === 'function' ? field(query) : field\n\n    return value === 'always' || (value !== false && isStale(query, options))\n  }\n  return false\n}\n\nfunction shouldFetchOptionally(\n  query: Query<any, any, any, any>,\n  prevQuery: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n  prevOptions: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return (\n    options.enabled !== false &&\n    (query !== prevQuery || prevOptions.enabled === false) &&\n    (!options.suspense || query.state.status !== 'error') &&\n    isStale(query, options)\n  )\n}\n\nfunction isStale(\n  query: Query<any, any, any, any>,\n  options: QueryObserverOptions<any, any, any, any, any>,\n): boolean {\n  return query.isStaleByTime(options.staleTime)\n}\n\n// this function would decide if we will update the observer's 'current'\n// properties after an optimistic reading via getOptimisticResult\nfunction shouldAssignObserverCurrentProperties<\n  TQueryFnData = unknown,\n  TError = unknown,\n  TData = TQueryFnData,\n  TQueryData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n>(\n  observer: QueryObserver<TQueryFnData, TError, TData, TQueryData, TQueryKey>,\n  optimisticResult: QueryObserverResult<TData, TError>,\n) {\n  // if the newly created result isn't what the observer is holding as current,\n  // then we'll need to update the properties as well\n  if (!shallowEqualObjects(observer.getCurrentResult(), optimisticResult)) {\n    return true\n  }\n\n  // basically, just keep previous properties if nothing changed\n  return false\n}\n"],"mappings":"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","names":[]}