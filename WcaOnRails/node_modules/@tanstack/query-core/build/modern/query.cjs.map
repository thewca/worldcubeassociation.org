{"version":3,"sources":["../../src/query.ts"],"sourcesContent":["import { noop, replaceData, timeUntilStale } from './utils'\nimport { notifyManager } from './notifyManager'\nimport { canFetch, createRetryer, isCancelledError } from './retryer'\nimport { Removable } from './removable'\nimport type {\n  CancelOptions,\n  DefaultError,\n  FetchStatus,\n  InitialDataFunction,\n  QueryFunctionContext,\n  QueryKey,\n  QueryMeta,\n  QueryOptions,\n  QueryStatus,\n  SetDataOptions,\n} from './types'\nimport type { QueryCache } from './queryCache'\nimport type { QueryObserver } from './queryObserver'\nimport type { Retryer } from './retryer'\n\n// TYPES\n\ninterface QueryConfig<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  cache: QueryCache\n  queryKey: TQueryKey\n  queryHash: string\n  options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state?: QueryState<TData, TError>\n}\n\nexport interface QueryState<TData = unknown, TError = DefaultError> {\n  data: TData | undefined\n  dataUpdateCount: number\n  dataUpdatedAt: number\n  error: TError | null\n  errorUpdateCount: number\n  errorUpdatedAt: number\n  fetchFailureCount: number\n  fetchFailureReason: TError | null\n  fetchMeta: FetchMeta | null\n  isInvalidated: boolean\n  status: QueryStatus\n  fetchStatus: FetchStatus\n}\n\nexport interface FetchContext<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  fetchFn: () => unknown | Promise<unknown>\n  fetchOptions?: FetchOptions\n  signal: AbortSignal\n  options: QueryOptions<TQueryFnData, TError, TData, any>\n  queryKey: TQueryKey\n  state: QueryState<TData, TError>\n}\n\nexport interface QueryBehavior<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> {\n  onFetch: (\n    context: FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n    query: Query,\n  ) => void\n}\n\nexport type FetchDirection = 'forward' | 'backward'\n\nexport interface FetchMeta {\n  fetchMore?: { direction: FetchDirection }\n}\n\nexport interface FetchOptions {\n  cancelRefetch?: boolean\n  meta?: FetchMeta\n}\n\ninterface FailedAction<TError> {\n  type: 'failed'\n  failureCount: number\n  error: TError\n}\n\ninterface FetchAction {\n  type: 'fetch'\n  meta?: FetchMeta\n}\n\ninterface SuccessAction<TData> {\n  data: TData | undefined\n  type: 'success'\n  dataUpdatedAt?: number\n  manual?: boolean\n}\n\ninterface ErrorAction<TError> {\n  type: 'error'\n  error: TError\n}\n\ninterface InvalidateAction {\n  type: 'invalidate'\n}\n\ninterface PauseAction {\n  type: 'pause'\n}\n\ninterface ContinueAction {\n  type: 'continue'\n}\n\ninterface SetStateAction<TData, TError> {\n  type: 'setState'\n  state: Partial<QueryState<TData, TError>>\n  setStateOptions?: SetStateOptions\n}\n\nexport type Action<TData, TError> =\n  | ContinueAction\n  | ErrorAction<TError>\n  | FailedAction<TError>\n  | FetchAction\n  | InvalidateAction\n  | PauseAction\n  | SetStateAction<TData, TError>\n  | SuccessAction<TData>\n\nexport interface SetStateOptions {\n  meta?: any\n}\n\n// CLASS\n\nexport class Query<\n  TQueryFnData = unknown,\n  TError = DefaultError,\n  TData = TQueryFnData,\n  TQueryKey extends QueryKey = QueryKey,\n> extends Removable {\n  queryKey: TQueryKey\n  queryHash: string\n  options!: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  state: QueryState<TData, TError>\n  isFetchingOptimistic?: boolean\n\n  #initialState: QueryState<TData, TError>\n  #revertState?: QueryState<TData, TError>\n  #cache: QueryCache\n  #promise?: Promise<TData>\n  #retryer?: Retryer<TData>\n  #observers: Array<QueryObserver<any, any, any, any, any>>\n  #defaultOptions?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>\n  #abortSignalConsumed: boolean\n\n  constructor(config: QueryConfig<TQueryFnData, TError, TData, TQueryKey>) {\n    super()\n\n    this.#abortSignalConsumed = false\n    this.#defaultOptions = config.defaultOptions\n    this.#setOptions(config.options)\n    this.#observers = []\n    this.#cache = config.cache\n    this.queryKey = config.queryKey\n    this.queryHash = config.queryHash\n    this.#initialState = config.state || getDefaultState(this.options)\n    this.state = this.#initialState\n    this.scheduleGc()\n  }\n  get meta(): QueryMeta | undefined {\n    return this.options.meta\n  }\n\n  #setOptions(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n  ): void {\n    this.options = { ...this.#defaultOptions, ...options }\n\n    this.updateGcTime(this.options.gcTime)\n  }\n\n  protected optionalRemove() {\n    if (!this.#observers.length && this.state.fetchStatus === 'idle') {\n      this.#cache.remove(this)\n    }\n  }\n\n  setData(\n    newData: TData,\n    options?: SetDataOptions & { manual: boolean },\n  ): TData {\n    const data = replaceData(this.state.data, newData, this.options)\n\n    // Set data and mark it as cached\n    this.#dispatch({\n      data,\n      type: 'success',\n      dataUpdatedAt: options?.updatedAt,\n      manual: options?.manual,\n    })\n\n    return data\n  }\n\n  setState(\n    state: Partial<QueryState<TData, TError>>,\n    setStateOptions?: SetStateOptions,\n  ): void {\n    this.#dispatch({ type: 'setState', state, setStateOptions })\n  }\n\n  cancel(options?: CancelOptions): Promise<void> {\n    const promise = this.#promise\n    this.#retryer?.cancel(options)\n    return promise ? promise.then(noop).catch(noop) : Promise.resolve()\n  }\n\n  destroy(): void {\n    super.destroy()\n\n    this.cancel({ silent: true })\n  }\n\n  reset(): void {\n    this.destroy()\n    this.setState(this.#initialState)\n  }\n\n  isActive(): boolean {\n    return this.#observers.some(\n      (observer) => observer.options.enabled !== false,\n    )\n  }\n\n  isDisabled(): boolean {\n    return this.getObserversCount() > 0 && !this.isActive()\n  }\n\n  isStale(): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      this.#observers.some((observer) => observer.getCurrentResult().isStale)\n    )\n  }\n\n  isStaleByTime(staleTime = 0): boolean {\n    return (\n      this.state.isInvalidated ||\n      !this.state.dataUpdatedAt ||\n      !timeUntilStale(this.state.dataUpdatedAt, staleTime)\n    )\n  }\n\n  onFocus(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnWindowFocus())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  onOnline(): void {\n    const observer = this.#observers.find((x) => x.shouldFetchOnReconnect())\n\n    observer?.refetch({ cancelRefetch: false })\n\n    // Continue fetch if currently paused\n    this.#retryer?.continue()\n  }\n\n  addObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (!this.#observers.includes(observer)) {\n      this.#observers.push(observer)\n\n      // Stop the query from being garbage collected\n      this.clearGcTimeout()\n\n      this.#cache.notify({ type: 'observerAdded', query: this, observer })\n    }\n  }\n\n  removeObserver(observer: QueryObserver<any, any, any, any, any>): void {\n    if (this.#observers.includes(observer)) {\n      this.#observers = this.#observers.filter((x) => x !== observer)\n\n      if (!this.#observers.length) {\n        // If the transport layer does not support cancellation\n        // we'll let the query continue so the result can be cached\n        if (this.#retryer) {\n          if (this.#abortSignalConsumed) {\n            this.#retryer.cancel({ revert: true })\n          } else {\n            this.#retryer.cancelRetry()\n          }\n        }\n\n        this.scheduleGc()\n      }\n\n      this.#cache.notify({ type: 'observerRemoved', query: this, observer })\n    }\n  }\n\n  getObserversCount(): number {\n    return this.#observers.length\n  }\n\n  invalidate(): void {\n    if (!this.state.isInvalidated) {\n      this.#dispatch({ type: 'invalidate' })\n    }\n  }\n\n  fetch(\n    options?: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n    fetchOptions?: FetchOptions,\n  ): Promise<TData> {\n    if (this.state.fetchStatus !== 'idle') {\n      if (this.state.dataUpdatedAt && fetchOptions?.cancelRefetch) {\n        // Silently cancel current fetch if the user wants to cancel refetch\n        this.cancel({ silent: true })\n      } else if (this.#promise) {\n        // make sure that retries that were potentially cancelled due to unmounts can continue\n        this.#retryer?.continueRetry()\n        // Return current promise if we are already fetching\n        return this.#promise\n      }\n    }\n\n    // Update config if passed, otherwise the config from the last execution is used\n    if (options) {\n      this.#setOptions(options)\n    }\n\n    // Use the options from the first observer with a query function if no function is found.\n    // This can happen when the query is hydrated or created with setQueryData.\n    if (!this.options.queryFn) {\n      const observer = this.#observers.find((x) => x.options.queryFn)\n      if (observer) {\n        this.#setOptions(observer.options)\n      }\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (!Array.isArray(this.options.queryKey)) {\n        console.error(\n          `As of v4, queryKey needs to be an Array. If you are using a string like 'repoData', please change it to an Array, e.g. ['repoData']`,\n        )\n      }\n    }\n\n    const abortController = new AbortController()\n\n    // Create query function context\n    const queryFnContext: Omit<QueryFunctionContext<TQueryKey>, 'signal'> = {\n      queryKey: this.queryKey,\n      meta: this.meta,\n    }\n\n    // Adds an enumerable signal property to the object that\n    // which sets abortSignalConsumed to true when the signal\n    // is read.\n    const addSignalProperty = (object: unknown) => {\n      Object.defineProperty(object, 'signal', {\n        enumerable: true,\n        get: () => {\n          this.#abortSignalConsumed = true\n          return abortController.signal\n        },\n      })\n    }\n\n    addSignalProperty(queryFnContext)\n\n    // Create fetch function\n    const fetchFn = () => {\n      if (!this.options.queryFn) {\n        return Promise.reject(\n          new Error(`Missing queryFn: '${this.options.queryHash}'`),\n        )\n      }\n      this.#abortSignalConsumed = false\n      if (this.options.persister) {\n        return this.options.persister(\n          this.options.queryFn,\n          queryFnContext as QueryFunctionContext<TQueryKey>,\n          this as unknown as Query,\n        )\n      }\n\n      return this.options.queryFn(\n        queryFnContext as QueryFunctionContext<TQueryKey>,\n      )\n    }\n\n    // Trigger behavior hook\n    const context: Omit<\n      FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      'signal'\n    > = {\n      fetchOptions,\n      options: this.options,\n      queryKey: this.queryKey,\n      state: this.state,\n      fetchFn,\n    }\n\n    addSignalProperty(context)\n\n    this.options.behavior?.onFetch(\n      context as FetchContext<TQueryFnData, TError, TData, TQueryKey>,\n      this as unknown as Query,\n    )\n\n    // Store state in case the current fetch needs to be reverted\n    this.#revertState = this.state\n\n    // Set to fetching state if not already in it\n    if (\n      this.state.fetchStatus === 'idle' ||\n      this.state.fetchMeta !== context.fetchOptions?.meta\n    ) {\n      this.#dispatch({ type: 'fetch', meta: context.fetchOptions?.meta })\n    }\n\n    const onError = (error: TError | { silent?: boolean }) => {\n      // Optimistically update state if needed\n      if (!(isCancelledError(error) && error.silent)) {\n        this.#dispatch({\n          type: 'error',\n          error: error as TError,\n        })\n      }\n\n      if (!isCancelledError(error)) {\n        // Notify cache callback\n        this.#cache.config.onError?.(\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n        this.#cache.config.onSettled?.(\n          this.state.data,\n          error as any,\n          this as Query<any, any, any, any>,\n        )\n      }\n\n      if (!this.isFetchingOptimistic) {\n        // Schedule query gc after fetching\n        this.scheduleGc()\n      }\n      this.isFetchingOptimistic = false\n    }\n\n    // Try to fetch the data\n    this.#retryer = createRetryer({\n      fn: context.fetchFn as () => Promise<TData>,\n      abort: abortController.abort.bind(abortController),\n      onSuccess: (data) => {\n        if (typeof data === 'undefined') {\n          if (process.env.NODE_ENV !== 'production') {\n            console.error(\n              `Query data cannot be undefined. Please make sure to return a value other than undefined from your query function. Affected query key: ${this.queryHash}`,\n            )\n          }\n          onError(new Error(`${this.queryHash} data is undefined`) as any)\n          return\n        }\n\n        this.setData(data)\n\n        // Notify cache callback\n        this.#cache.config.onSuccess?.(data, this as Query<any, any, any, any>)\n        this.#cache.config.onSettled?.(\n          data,\n          this.state.error as any,\n          this as Query<any, any, any, any>,\n        )\n\n        if (!this.isFetchingOptimistic) {\n          // Schedule query gc after fetching\n          this.scheduleGc()\n        }\n        this.isFetchingOptimistic = false\n      },\n      onError,\n      onFail: (failureCount, error) => {\n        this.#dispatch({ type: 'failed', failureCount, error })\n      },\n      onPause: () => {\n        this.#dispatch({ type: 'pause' })\n      },\n      onContinue: () => {\n        this.#dispatch({ type: 'continue' })\n      },\n      retry: context.options.retry,\n      retryDelay: context.options.retryDelay,\n      networkMode: context.options.networkMode,\n    })\n\n    this.#promise = this.#retryer.promise\n\n    return this.#promise\n  }\n\n  #dispatch(action: Action<TData, TError>): void {\n    const reducer = (\n      state: QueryState<TData, TError>,\n    ): QueryState<TData, TError> => {\n      switch (action.type) {\n        case 'failed':\n          return {\n            ...state,\n            fetchFailureCount: action.failureCount,\n            fetchFailureReason: action.error,\n          }\n        case 'pause':\n          return {\n            ...state,\n            fetchStatus: 'paused',\n          }\n        case 'continue':\n          return {\n            ...state,\n            fetchStatus: 'fetching',\n          }\n        case 'fetch':\n          return {\n            ...state,\n            fetchFailureCount: 0,\n            fetchFailureReason: null,\n            fetchMeta: action.meta ?? null,\n            fetchStatus: canFetch(this.options.networkMode)\n              ? 'fetching'\n              : 'paused',\n            ...(!state.dataUpdatedAt && {\n              error: null,\n              status: 'pending',\n            }),\n          }\n        case 'success':\n          return {\n            ...state,\n            data: action.data,\n            dataUpdateCount: state.dataUpdateCount + 1,\n            dataUpdatedAt: action.dataUpdatedAt ?? Date.now(),\n            error: null,\n            isInvalidated: false,\n            status: 'success',\n            ...(!action.manual && {\n              fetchStatus: 'idle',\n              fetchFailureCount: 0,\n              fetchFailureReason: null,\n            }),\n          }\n        case 'error':\n          const error = action.error as unknown\n\n          if (isCancelledError(error) && error.revert && this.#revertState) {\n            return { ...this.#revertState, fetchStatus: 'idle' }\n          }\n\n          return {\n            ...state,\n            error: error as TError,\n            errorUpdateCount: state.errorUpdateCount + 1,\n            errorUpdatedAt: Date.now(),\n            fetchFailureCount: state.fetchFailureCount + 1,\n            fetchFailureReason: error as TError,\n            fetchStatus: 'idle',\n            status: 'error',\n          }\n        case 'invalidate':\n          return {\n            ...state,\n            isInvalidated: true,\n          }\n        case 'setState':\n          return {\n            ...state,\n            ...action.state,\n          }\n      }\n    }\n\n    this.state = reducer(this.state)\n\n    notifyManager.batch(() => {\n      this.#observers.forEach((observer) => {\n        observer.onQueryUpdate()\n      })\n\n      this.#cache.notify({ query: this, type: 'updated', action })\n    })\n  }\n}\n\nfunction getDefaultState<\n  TQueryFnData,\n  TError,\n  TData,\n  TQueryKey extends QueryKey,\n>(\n  options: QueryOptions<TQueryFnData, TError, TData, TQueryKey>,\n): QueryState<TData, TError> {\n  const data =\n    typeof options.initialData === 'function'\n      ? (options.initialData as InitialDataFunction<TData>)()\n      : options.initialData\n\n  const hasData = typeof data !== 'undefined'\n\n  const initialDataUpdatedAt = hasData\n    ? typeof options.initialDataUpdatedAt === 'function'\n      ? (options.initialDataUpdatedAt as () => number | undefined)()\n      : options.initialDataUpdatedAt\n    : 0\n\n  return {\n    data,\n    dataUpdateCount: 0,\n    dataUpdatedAt: hasData ? initialDataUpdatedAt ?? Date.now() : 0,\n    error: null,\n    errorUpdateCount: 0,\n    errorUpdatedAt: 0,\n    fetchFailureCount: 0,\n    fetchFailureReason: null,\n    fetchMeta: null,\n    isInvalidated: false,\n    status: hasData ? 'success' : 'pending',\n    fetchStatus: 'idle',\n  }\n}\n"],"mappings":"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","names":[]}